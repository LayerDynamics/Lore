---
name: test-scaling
description: Test a component under simulated scale conditions — generate load scenarios and verify behavior at increasing volumes.
argument-hint: <path or component> [--level <10x|100x|1000x>]
---

# Test Scaling

Generate and run scaling tests to verify a component behaves correctly under load.

**Arguments:** $ARGUMENTS

## Workflow

### Step 1: Parse Arguments

Extract from `$ARGUMENTS`:
- **Target**: path to the component or module to test
- **Scale level**: `--level 10x` (default), `100x`, or `1000x`

### Step 2: Analyze the Component

Read the target component and identify:
- Entry point functions (what gets called under load)
- Input parameters (what varies with scale)
- Expected outputs (what to assert)
- Side effects (files written, network calls, state changes)

### Step 3: Generate Scale Test

Create a test script that:

1. **Generates scaled input data**
   - For 10x: 10x the typical input size
   - For 100x: 100x the typical input size
   - Use realistic data distributions, not just duplicated records

2. **Measures key metrics**
   - Wall clock time
   - Memory usage (before and after)
   - Output correctness (spot-check results)

3. **Runs progressively**
   - 1x baseline first
   - Then target scale level
   - Compare metrics between runs

### Step 4: Write the Test Script

Write a test file at `<target-dir>/scale-test.mjs`:

```javascript
// Scale test for [component]
// Generated by /scale-review:test-scaling

const SCALE = parseInt(process.env.SCALE || '10', 10);

async function generateInput(scale) {
  // Generate realistic input at given scale
}

async function measureRun(label, input) {
  const memBefore = process.memoryUsage();
  const start = performance.now();

  const result = await runComponent(input);

  const elapsed = performance.now() - start;
  const memAfter = process.memoryUsage();

  console.log(`[${label}] Time: ${elapsed.toFixed(0)}ms`);
  console.log(`[${label}] Heap: +${((memAfter.heapUsed - memBefore.heapUsed) / 1024 / 1024).toFixed(1)}MB`);

  return { elapsed, memDelta: memAfter.heapUsed - memBefore.heapUsed, result };
}

const baseInput = await generateInput(1);
const baseline = await measureRun('1x', baseInput);

const scaledInput = await generateInput(SCALE);
const scaled = await measureRun(`${SCALE}x`, scaledInput);

const timeRatio = scaled.elapsed / baseline.elapsed;
const memRatio = scaled.memDelta / (baseline.memDelta || 1);

console.log(`\nScaling factor: ${SCALE}x`);
console.log(`Time grew: ${timeRatio.toFixed(1)}x (ideal: ${SCALE}x linear)`);
console.log(`Memory grew: ${memRatio.toFixed(1)}x`);

if (timeRatio > SCALE * 2) {
  console.log('WARNING: Super-linear time growth detected');
}
if (memRatio > SCALE * 2) {
  console.log('WARNING: Super-linear memory growth detected');
}
```

### Step 5: Run and Report

Execute the test with `node scale-test.mjs` and present results:

```markdown
## Scale Test Results: [Component]

**Scale level**: [10x | 100x | 1000x]

| Metric | 1x (baseline) | [N]x (scaled) | Growth |
|--------|---------------|---------------|--------|
| Time | Xms | Xms | X.Xx |
| Memory | XMB | XMB | X.Xx |
| Correctness | pass | pass/fail | — |

**Verdict**: [scales-linearly | super-linear-time | super-linear-memory | fails-at-scale]

**Bottleneck**: [identified component or path if growth is super-linear]
```

If super-linear growth is detected, recommend running `/scale-review:hone` on the specific bottleneck.
